if (AimWhileJumping) { //Allows you to ADS when You are in the Air
		Driver::write<bool>(pid, LocalPawn + 0x3F41, true); //bADSWhileNotOnGround
 }
	else {
		Driver::write<bool>(pid, LocalPawn + 0x3F41, false); //bADSWhileNotOnGround
 }
 
if (NoEquipAnimation) { //Disables the animation when switching guns also makes equip delay 0
		Driver::write<bool>(pid, CurrentWeapon + 0x2C3, true); //bDisableEquipAnimation
	}
	else {
	    	Driver::write<bool>(pid, CurrentWeapon + 0x2C3, false); //bDisableEquipAnimation
	}
 
 if (RapidFire) { //Makes your gun shoot Faster
		float LastFireTime = 0;
		float LastFireTimeVerified = 0;
	   	 LastFireTime = Driver::read<float>(pid, CurrentWeapon1 + 0x9F4); //LastFireTime
			LastFireTimeVerified = Driver::read<float>(pid, CurrentWeapon1 + 0x9F8); //LastFireTimeVerified
			  Driver::write<float>(pid, CurrentWeapon + 0x9F4, LastFireTime + LastFireTimeVerified - 0.003); //RapidFire value
	  }
    
if (AirStuck) {  //Freezes You in the Air
		  if (GetAsyncKeyState(VK_MENU)) { //Alt Keybind
				Driver::write<float>(pid, LocalPawn + 0x9C, 0); //CustomTimeDilation
			}
			else {
				Driver::write<float>(pid, LocalPawn + 0x9C, 1); //CustomTimeDilation
			}
	}
  
if (InstantRevive) { //Revives Teammates in 1 Second
		  Driver::write<float>(pid, LocalPawn + 0x37D8, 1); //ReviveFromDBNOTime
	}
  
if (FOVChanger) { //Changes your FOV
		  Driver::write<float>(pid, PlayerCameraManager + 0x23C, FOVValue); //No Clue
  	 }
 
//TriggerType Class
enum class EFortWeaponTriggerType : uint8_t
{
	OnPress = 0,
	Automatic = 1,
	OnRelease = 2,
	OnPressAndRelease = 3,
	EFortWeaponTriggerType_MAX = 4
};

if (AutoWeapons) { //Makes ALL Guns Automatic (Pistol, Shotgun, etc.)
		EFortWeaponTriggerType Trigger = Driver::read<EFortWeaponTriggerType>(pid, WeaponData + 0xadc); //TriggerType
		Trigger = EFortWeaponTriggerType::Automatic;
		Driver::write<EFortWeaponTriggerType>(pid, WeaponData + 0xadc, Trigger); //TriggerType
    }
 
 struct FZiplinePawnState { //Zipline Struct
	struct AFortAthenaZiplineBase* Zipline; // 0x00(0x08)
	struct AFortAthenaZiplineBase* PreviousZipline; // 0x00(0x08)
	struct UPrimitiveComponent* InteractComponent; // 0x10(0x08)
	bool bIsZiplining; // 0x18(0x01)
	bool bJumped; // 0x19(0x01)
	bool bReachedEnd; // 0x1a(0x01)
	char pad_1B[0x1]; // 0x1b(0x01)
	int32_t AuthoritativeValue; // 0x1c(0x04)struct sdk::structs::FVector SocketOffset; // 0x20(0x0c)
	float TimeZipliningBegan; // 0x2c(0x04)
	float TimeZipliningEndedFromJump; // 0x30(0x04)
	char pad_34[0x4]; // 0x34(0x04)
};

if (ZiplineFly) { //Allows you to fly
		FZiplinePawnState ZiplinePawnState = Driver::read<FZiplinePawnState>(pid, LocalPawn + 0x18D0); //ZiplineState
		ZiplinePawnState.bIsZiplining = true;
		ZiplinePawnState.AuthoritativeValue = 360.f;
		Driver::write<FZiplinePawnState>(pid, LocalPawn + 0x18D0, ZiplinePawnState); //ZiplineState
	}
 
 if (ChangeCrosshairColor) { //Changes the color of the ingame crosshair VERY MESSY (ik)
		Driver::write<char>(pid, CurrentWeapon + 0x550, B); //B //ReticleDefaultColor
		Driver::write<char>(pid, CurrentWeapon + 0x550 + 0x1, G); //G //ReticleDefaultColor
		Driver::write<char>(pid, CurrentWeapon + 0x550 + 0x2, R); //R //ReticleDefaultColor

		Driver::write<char>(pid, CurrentWeapon + 0x55c, B); //B //ReticleNoTargetColor
		Driver::write<char>(pid, CurrentWeapon + 0x55c + 0x1, G); //G //ReticleNoTargetColor
		Driver::write<char>(pid, CurrentWeapon + 0x55c + 0x2, R); //R //ReticleNoTargetColor

		Driver::write<char>(pid, CurrentWeapon + 0x558, B); //B //ReticleBuildingColor
		Driver::write<char>(pid, CurrentWeapon + 0x558 + 0x1, G); //G //ReticleBuildingColor
		Driver::write<char>(pid, CurrentWeapon + 0x558 + 0x2, R); //R //ReticleBuildingColor

		Driver::write<char>(pid, CurrentWeapon + 0x554, B); //B //ReticleEnemyColor
		Driver::write<char>(pid, CurrentWeapon + 0x554 + 0x1, G); //G //ReticleEnemyColor
		Driver::write<char>(pid, CurrentWeapon + 0x554 + 0x2, R); //R //ReticleEnemyColor
	}
